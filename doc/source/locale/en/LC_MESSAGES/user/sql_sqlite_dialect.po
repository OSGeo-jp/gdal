# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-31 22:42+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../source/user/sql_sqlite_dialect.rst:5
msgid "SQL SQLite dialect"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:9
msgid ""
"The ``SQLite`` dialect can be used as an alternate SQL dialect to the "
":ref:`ogr_sql_dialect`. This assumes that GDAL/OGR is built with support "
"for SQLite, and preferably with `Spatialite <https://www.gaia-"
"gis.it/fossil/libspatialite/index>`_ support too to benefit from spatial "
"functions."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:14
msgid ""
"The SQLite dialect may be used with any OGR datasource, like the OGR SQL "
"dialect. The ``SQLite`` dialect can be requested with the ``SQLite`` "
"string passed as the dialect parameter of "
":cpp:func:`GDALDataset::ExecuteSQL`, or with the `-dialect` option of the"
" :ref:`ogrinfo` or :ref:`ogr2ogr` utilities."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:19
msgid ""
"This is mainly aimed to execute SELECT statements, but, for datasources "
"that support update, INSERT/UPDATE/DELETE statements can also be run. "
"GDAL is internally using `the Virtual Table Mechanism of SQLite "
"<https://sqlite.org/vtab.html>`_ and therefore operations like ALTER "
"TABLE are not supported. For executing ALTER TABLE or DROP TABLE use "
":ref:`ogr_sql_dialect`"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:25
msgid ""
"If the datasource is SQLite database (GeoPackage, SpatiaLite) then SQLite"
" dialect acts as native SQL dialect and Virtual Table Mechanism is not "
"used. It is possible to force GDAL to use Virtual Tables even in this "
"case by specifying \"-dialect INDIRECT_SQLITE\". This should be used only"
" when necessary, since going through the virtual table mechanism might "
"affect performance."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:31
msgid ""
"The syntax of the SQL statements is fully the one of the SQLite SQL "
"engine. You can refer to the following pages:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:34
msgid "`SELECT <http://www.sqlite.org/lang_select.html>`_"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:35
msgid "`INSERT <http://www.sqlite.org/lang_insert.html>`_"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:36
msgid "`UPDATE <http://www.sqlite.org/lang_update.html>`_"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:37
msgid "`DELETE <http://www.sqlite.org/lang_delete.html>`_"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:40
msgid "SELECT statement"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:42
msgid ""
"The SELECT statement is used to fetch layer features (analogous to table "
"rows in an RDBMS) with the result of the query represented as a temporary"
" layer of features. The layers of the datasource are analogous to tables "
"in an RDBMS and feature attributes are analogous to column values. The "
"simplest form of OGR SQLITE SELECT statement looks like this:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:52
msgid ""
"More complex statements can of course be used, including WHERE, JOIN, "
"USING, GROUP BY, ORDER BY, sub SELECT, ..."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:55
msgid ""
"The table names that can be used are the layer names available in the "
"datasource on which the ExecuteSQL() method is called."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:58
msgid ""
"Similarly to OGRSQL, it is also possible to refer to layers of other "
"datasources with the following syntax : "
"\"other_datasource_name\".\"layer_name\"."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:65
msgid ""
"If the master datasource is SQLite database (GeoPackage, SpatiaLite) it "
"is necessary to use indirect SQLite dialect. Otherwise additional "
"datasources are never opened but tables to be used in joins are searched "
"from the master database."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:74
msgid ""
"The column names that can be used in the result column list, in WHERE, "
"JOIN, ... clauses are the field names of the layers. Expressions, SQLite "
"functions, spatial functions, etc... can also be used."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:79
msgid ""
"The conditions on fields expressed in WHERE clauses, or in JOINs are "
"translated, as far as possible, as attribute filters that are applied on "
"the underlying OGR layers. Joins can be very expensive operations if the "
"secondary table is not indexed on the key field being used."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:85
msgid "LIKE operator"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:87
msgid ""
"In SQLite, the LIKE operator is case insensitive, unless ``PRAGMA "
"case_sensitive_like = 1`` has been issued."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:90
msgid ""
"Starting with GDAL 3.9, GDAL installs a custom LIKE comparison, such that"
" UTF-8 characters are taken into account by ``LIKE`` operator."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:93
msgid ""
"For case insensitive comparisons, this is restricted to the `ASCII "
"<https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)>`__, `Latin-1 "
"Supplement <https://en.wikipedia.org/wiki/Latin-"
"1_Supplement_(Unicode_block)>`__, `Latin Extended-A "
"<https://en.wikipedia.org/wiki/Latin_Extended-A>`__, `Latin Extended-B "
"<https://en.wikipedia.org/wiki/Latin_Extended-B>`__, `Greek and Coptic "
"<https://en.wikipedia.org/wiki/Greek_and_Coptic>`__ and `Cyrillic "
"<https://en.wikipedia.org/wiki/Greek_and_Coptic>`__ Unicode categories."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:102
msgid "Delimited identifiers"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:104
msgid ""
"If names of layers or attributes are reserved keywords in SQL like 'FROM'"
" or they begin with a number or underscore they must be handled as "
"\"delimited identifiers\" and enclosed between double quotation marks in "
"queries. Double quotes can be used even when they are not strictly "
"needed."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:113
msgid ""
"When SQL statements are used in the command shell and the statement "
"itself is put between double quotes, the internal double quotes must be "
"escaped with \\\\"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:121
msgid "Geometry field"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:123
msgid ""
"Geometry fields can be explicitly specified in the result column list of "
"a SELECT, or automatically selected if the * wildcard is used."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:126
msgid ""
"For OGR layers that have a non-empty geometry column name (generally for "
"RDBMS datasources), as returned by OGRLayer::GetGeometryColumn(), the "
"name of the geometry special field in the SQL statement must be the name "
"of the geometry column of the underlying OGR layer. If the name of the "
"geometry column in the source layer is empty, like with shapefiles etc., "
"the name to use in the SQL statement must be \"geometry\". Here we'll use"
" it case-insensitively (as all field names are in a SELECT statement):"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:137
#: ../../source/user/sql_sqlite_dialect.rst:149
#: ../../source/user/sql_sqlite_dialect.rst:226
#: ../../source/user/sql_sqlite_dialect.rst:355
#: ../../source/user/sql_sqlite_dialect.rst:366
msgid "returns:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:160
msgid "Feature id (FID)"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:162
msgid ""
"The feature id is a special property of a feature and not treated as an "
"attribute of the feature.  In some cases it is convenient to be able to "
"utilize the feature id in queries and result sets as a regular field.  To"
" do so use the name ``rowid``."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:167
msgid ""
"Starting with GDAL 3.8, if the layer has a named FID column "
"(:cpp:func:`OGRLayer::GetFIDColumn` != \"\"), this name may also be used."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:170
msgid ""
"The field wildcard expansions will not include the feature id, but it may"
" be explicitly included using a syntax like:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:177
msgid "It is of course possible to rename it:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:184
msgid "OGR_STYLE special field"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:186
msgid ""
"The ``OGR_STYLE`` special field represents the style string of the "
"feature returned by OGRFeature::GetStyleString(). By using this field and"
" the ``LIKE`` operator the result of the query can be filtered by the "
"style. For example we can select the annotation features as:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:196
msgid "Statistics functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:198
msgid ""
"In addition to standard COUNT(), SUM(), AVG(), MIN(), MAX(), the "
"following aggregate functions are available:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:201
msgid ""
"``STDDEV_POP(numeric_value)``: (GDAL >= 3.10) numerical population "
"standard deviation."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:202
msgid ""
"``STDDEV_SAMP(numeric_value)``: (GDAL >= 3.10) numerical `sample standard"
" deviation "
"<https://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation>`__"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:205
msgid "Ordered-set aggregate functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:207
msgid ""
"The following aggregate functions are available. Note that they require "
"to allocate an amount of memory proportional to the number of selected "
"rows (for ``MEDIAN``, ``PERCENTILE`` and ``PERCENTILE_CONT``) or to the "
"number of values (for ``MODE``)."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:209
msgid ""
"``MEDIAN(numeric_value)``: (GDAL >= 3.10) (continuous) median (equivalent"
" to ``PERCENTILE(numeric_value, 50)``). NULL values are ignored."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:210
msgid ""
"``PERCENTILE(numeric_value, percentage)``: (GDAL >= 3.10) (continuous) "
"percentile, with percentage between 0 and 100 (equivalent to "
"``PERCENTILE_CONT(numeric_value, percentage / 100)``). NULL values are "
"ignored."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:211
msgid ""
"``PERCENTILE_CONT(numeric_value, fraction)``: (GDAL >= 3.10) (continuous)"
" percentile, with fraction between 0 and 1. NULL values are ignored."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:212
msgid ""
"``MODE(value)``: (GDAL >= 3.10): mode, i.e. most frequent input value "
"(strings and numeric values are supported), arbitrarily choosing the "
"first one if there are multiple equally-frequent results. NULL values are"
" ignored."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:215
msgid "Spatialite SQL functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:217
msgid ""
"When GDAL/OGR is build with support for the `Spatialite <https://www"
".gaia-gis.it/fossil/libspatialite/index>`_ library, a lot of `extra SQL "
"functions <http://www.gaia-gis.it/gaia-sins/spatialite-sql-"
"latest.html>`_, in particular spatial functions, can be used in results "
"column fields, WHERE clauses, etc...."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:242
msgid ""
"Note that due to the loose typing mechanism of SQLite, if a geometry "
"expression returns a NULL value for the first row, this will generally "
"cause OGR not to recognize the column as a geometry column. It might be "
"then useful to sort the results by making sure that non-null geometries "
"are returned first:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:252
msgid "OGR datasource SQL functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:254
msgid ""
"The ``ogr_datasource_load_layers(datasource_name[, update_mode[, "
"prefix]])`` function can be used to automatically load all the layers of "
"a datasource as :ref:`VirtualOGR tables <vector.sqlite>`."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:270
msgid "OGR layer SQL functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:272
msgid ""
"The following SQL functions are available and operate on a layer name : "
"``ogr_layer_Extent()``, ``ogr_layer_SRID()``, "
"``ogr_layer_GeometryType()`` and ``ogr_layer_FeatureCount()``"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:290
msgid "OGR compression functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:292
msgid ""
"``ogr_deflate(text_or_blob[, compression_level])`` returns a binary blob "
"compressed with the ZLib deflate algorithm. See "
":cpp:func:`CPLZLibDeflate`"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:295
msgid ""
"``ogr_inflate(compressed_blob)`` returns the decompressed binary blob, "
"from a blob compressed with the ZLib deflate algorithm. If the "
"decompressed binary is a string, use CAST(ogr_inflate(compressed_blob) AS"
" VARCHAR). See CPLZLibInflate()."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:301
msgid "Other functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:303
msgid ""
"The ``hstore_get_value()`` function can be used to extract a value "
"associate to a key from a HSTORE string, formatted like "
"\"key=>value,other_key=>other_value,...\""
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:313
msgid "Raster related functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:315
msgid ""
"The ``gdal_get_pixel_value()`` function (added in GDAL 3.7) can be used "
"to extract the value of a pixel in a GDAL dataset. It requires the "
"configuration option OGR_SQLITE_ALLOW_EXTERNAL_ACCESS to be set to YES "
"(for security reasons)."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:319
msgid "It takes 5 or 6 arguments:"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:321
msgid "a string with the dataset name"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:322
msgid "a band number (numbering starting at 1)"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:323
msgid ""
"a string being \"georef\" to indicate that subsequent values will be "
"georeferenced coordinates, or \"pixel\" to indicate that subsequent "
"values will be in column, line pixel space"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:326
msgid "georeferenced X value or column number"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:327
msgid "georeferenced Y value or line number"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:328
msgid ""
"resampling method among ``nearest`` (default), ``bilinear``, ``cubic``, "
"``cubicspline``. Optional, added in GDAL 3.10"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:338
msgid "OGR geocoding functions"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:340
msgid ""
"The following SQL functions are available : ``ogr_geocode(...)`` and "
"``ogr_geocode_reverse(...)``."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:342
msgid ""
"``ogr_geocode(name_to_geocode [, field_to_return [, option1 [, option2, "
"...]]])`` where name_to_geocode is a literal or a column name that must "
"be geocoded. field_to_return if specified can be \"geometry\" for the "
"geometry (default), or a field name of the layer returned by "
":cpp:func:`OGRGeocode`. The special field  \"raw\" can also be used to "
"return the raw response (XML string) of the geocoding service. option1, "
"option2, etc.. must be of the key=value format, and are options "
"understood by :cpp:func:`OGRGeocodeCreateSession` or OGRGeocode()."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:349
msgid ""
"This function internally uses the OGRGeocode() API. Refer to it for more "
"details."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:401
msgid ""
"``ogr_geocode_reverse(longitude, latitude, field_to_return [, option1 [, "
"option2, ...]])`` where longitude, latitude is the coordinate to query. "
"field_to_return must be a field name of the layer returned by "
"OGRGeocodeReverse() (for example 'display_name'). The special field  "
"\"raw\" can also be used to return the raw response (XML string) of the "
"geocoding service. option1, option2, etc.. must be of the key=value "
"format, and are options understood by OGRGeocodeCreateSession() or "
"OGRGeocodeReverse()."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:408
msgid ""
"``ogr_geocode_reverse(geometry, field_to_return [, option1 [, option2, "
"...]])`` is also accepted as an alternate syntax where geometry is a "
"(Spatialite) point geometry."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:411
msgid ""
"This function internally uses the :cpp:func:`OGRGeocodeReverse` API. "
"Refer to it for more details."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:414
msgid "Spatialite spatial index"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:416
msgid ""
"Spatialite spatial index mechanism can be triggered by making sure a "
"spatial index virtual table is mentioned in the SQL (of the form "
"idx_layername_geometrycolumn), or by using the more recent SpatialIndex "
"from the VirtualSpatialIndex extension. In which case, a in-memory RTree "
"will be built to be used to speed up the spatial queries."
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:421
msgid ""
"For example, a spatial intersection between 2 layers, by using a spatial "
"index on one of the layers to limit the number of actual geometry "
"intersection computations :"
msgstr ""

#: ../../source/user/sql_sqlite_dialect.rst:433
msgid "or more elegantly :"
msgstr ""

#~ msgid "It takes 5 arguments:"
#~ msgstr ""

#~ msgid ""
#~ "Starting with GDAL 3.9, GDAL installs"
#~ " a custom LIKE comparison, such that"
#~ " UTF-8 characters are taken into "
#~ "account by ``LIKE`` and ``ILIKE`` "
#~ "operators. For ILIKE case insensitive "
#~ "comparisons, this is restricted to the"
#~ " `ASCII "
#~ "<https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)>`__, "
#~ "`Latin-1 Supplement <https://en.wikipedia.org/wiki"
#~ "/Latin-1_Supplement_(Unicode_block)>`__, `Latin "
#~ "Extended-A <https://en.wikipedia.org/wiki/Latin_Extended-A>`__,"
#~ " `Latin Extended-B "
#~ "<https://en.wikipedia.org/wiki/Latin_Extended-B>`__, `Greek "
#~ "and Coptic "
#~ "<https://en.wikipedia.org/wiki/Greek_and_Coptic>`__ and "
#~ "`Cyrillic <https://en.wikipedia.org/wiki/Greek_and_Coptic>`__"
#~ " Unicode categories."
#~ msgstr ""

#~ msgid ""
#~ "The ``GEOMETRY`` special field represents "
#~ "the geometry of the feature returned "
#~ "by OGRFeature::GetGeometryRef(). It can be "
#~ "explicitly specified in the result "
#~ "column list of a SELECT, and is"
#~ " automatically selected if the * "
#~ "wildcard is used."
#~ msgstr ""

#~ msgid ""
#~ "For OGR layers that have a non-"
#~ "empty geometry column name (generally "
#~ "for RDBMS datasources), as returned by"
#~ " OGRLayer::GetGeometryColumn(), the name of "
#~ "the geometry special field in the "
#~ "SQL statement will be the name of"
#~ " the geometry column of the "
#~ "underlying OGR layer. If the name "
#~ "of the geometry column in the "
#~ "source layer is empty, like with "
#~ "shapefiles etc., the name to use "
#~ "in the SQL statement is always "
#~ "\"geometry\". Here we'll use it case-"
#~ "insensitively (as all field names are"
#~ " in a SELECT statement):"
#~ msgstr ""

#~ msgid "STDDEV_POP: (GDAL >= 3.10) numerical population standard deviation."
#~ msgstr ""

#~ msgid ""
#~ "STDDEV_SAMP: (GDAL >= 3.10) numerical "
#~ "`sample standard deviation "
#~ "<https://en.wikipedia.org/wiki/Standard_deviation#Sample_standard_deviation>`__"
#~ msgstr ""

