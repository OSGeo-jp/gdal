# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-31 22:42+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:5
msgid "RFC 101: Raster dataset read-only thread-safety"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:8
msgid "Author:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:8
msgid "Even Rouault"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:9
msgid "Contact:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:9
msgid "even.rouault @ spatialys.com"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:10
msgid "Started:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:10
msgid "2024-Aug-29"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:11
msgid "Status:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:11
msgid "Adopted, implemented"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:12
msgid "Target:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:12
msgid "GDAL 3.10"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:16
msgid "Summary"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:18
msgid ""
"This RFC enables users to get instances of :cpp:class:`GDALDataset` (and "
"their related objects such as :cpp:class:`GDALRasterBand`) that are "
"thread-safe for read-only raster operations, that is such instances can "
"be safely used from multiple threads without locking."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:24
msgid "Terminology"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:26
msgid ""
"The exact meaning of the terms ``thread-safe`` or ``re-entrant`` is not "
"fully standardized. We will use here the `QT definitions "
"<https://doc.qt.io/qt-5/threads-reentrancy.html>`__. In particular, a C "
"function or C++ method is said to be re-entrant if it can be called "
"simultaneously from multiple threads, *but* only if each invocation uses "
"its own data/instance. On the contrary, it is thread-safe is if can be "
"called on the same data/instance (so thread-safe is stronger than re-"
"entrant)"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:34
msgid "Motivation"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:36
msgid ""
"A number of raster algorithms can be designed to read chunks of a raster "
"in an independent and concurrent way, with resulting speed-ups when using"
" multi-threading. Currently, given a GDALDataset instance is not thread-"
"safe, this requires either to deal with I/O in a single thread, or "
"through a mutex to protect against concurrent use, or one needs to open a"
" separate GDALDataset for each worker thread. Both approaches can "
"complicate the writing of such algorithms. The enhancement of this RFC "
"aims at providing a special GDALDataset instance that can be used safely "
"from multiple threads. Internally, it does use one GDALDataset per "
"thread, but hides this implementation detail to the user."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:47
msgid "C and C++ API extensions"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:49
msgid ""
"A new ``GDAL_OF_THREAD_SAFE`` opening flag is added to be specified to "
":cpp:func:`GDALOpenEx` / :cpp:func:`GDALDataset::Open`. This flag is for "
"now mutually exclusive with ``GDAL_OF_VECTOR``, "
"``GDAL_OF_MULTIDIM_RASTER`` and ``GDAL_OF_UPDATE``. That is this flag is "
"only meant for read-only raster operations (``GDAL_OF_RASTER | "
"GDAL_OF_THREAD_SAFE``)."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:55
msgid ""
"To know if a given dataset can be used in a thread-safe way, the "
"following C++ method is added to the GDALDataset class:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:75
msgid "The corresponding C function is added:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:83
msgid "A new C++ function, GDALGetThreadSafeDataset, is added with two forms:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:91
msgid ""
"This function accepts a (generally non thread-safe) source dataset and "
"return a new dataset that is a thread-safe wrapper around it, or the "
"source dataset if it is already thread-safe. The nScopeFlags argument "
"must be compulsory set to GDAL_OF_RASTER to express that the intended "
"scope is read-only raster operations (other values will result in an "
"error and a NULL returned dataset). This function is used internally by "
"GDALOpenEx() when the GDAL_OF_THREAD_SAFE flag is passed to wrap the "
"dataset returned by the driver. The first form takes ownership of the "
"source dataset. The second form does not, but references it internally, "
"and assumes that its lifetime will be longer than the lifetime of the "
"returned thread-safe dataset. Note that the second form does increase the"
" reference count on the passed dataset while it is being used, so "
"patterns like the following one are valid:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:117
msgid ""
"For proper working both when a new dataset is returned or the passed one "
"if it is already thread-safe, :cpp:func:`GDALDataset::ReleaseRef()` (and "
"not delete or GDALClose()) must be called on the returned dataset."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:122
msgid "The corresponding C function for the second form is added:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:130
msgid "Usage examples"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:132
msgid "Example of a function processing a whole dataset passed as a filename:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:149
msgid "Example of a function processing a whole dataset passed as an object:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:170
msgid "Example of a function processing a single band passed as an object:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:203
msgid "SWIG bindings"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:205
msgid "The new C macro and functions are bound to SWIG as:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:207
msgid "``gdal.OF_THREAD_SAFE``"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:208
msgid ":py:func:`Dataset.IsThreadSafe(nScopeFlags)`"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:209
msgid ""
":py:func:`Dataset.GetThreadSafeDataset(nScopeFlags)`. The Python "
"implementation of this method takes care of keeping a reference on the "
"source dataset in the returned thread-safe dataset, so the user does not "
"have to care about their respective lifetimes."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:215
msgid "Usage and design limitations"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:217
msgid ""
"As implied by the RFC title, the scope of thread-safety is restricted to "
"**raster** and **read-only** operations."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:220
msgid ""
"For GDALDataset instances pointing to a file on the regular filesystem, "
"the limitation of the maximum number of file descriptor opened by a "
"process (1024 on most Linux systems) could be hit if working with a "
"sufficiently large number of worker threads and/or instances of "
"GDALThreadSafeDataset."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:225
msgid ""
"The generic implementation of GDALGetThreadSafeDataset assumes that the "
"source dataset can be re-opened by its name (GetDescription()), which is "
"the case for datasets opened by GDALOpenEx(). A special implementation is"
" also made for dataset instances of the MEM driver. But, there is "
"currently no support for creating a thread-safe dataset wrapper on on-"
"the-fly datasets returned by some algorithms (e.g GDALTranslate() or "
"GDALWarp() with VRT as the output driver and with an empty filename, or "
"custom GDALDataset implementation by external code)."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:234
msgid ""
"Inherent to the selected approach, there is a band block cache per "
"thread, and thus no sharing of cached blocks between threads. However, "
"this should not be a too severe limitation for algorithms where threads "
"process independent regions of the raster, hence reuse of cached blocks "
"would be non-existent or low. Optimal algorithms will make sure to work "
"on regions of interest aligned on the block size (this advice also "
"applies for the current approach of manually opening a dataset for each "
"worker thread)."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:242
msgid ""
"Due to implementation limitations, "
":cpp:func:`GDALRasterBand::GetDefaultRAT` on a GDALThreadSafeDataset "
"instance only works if the RAT is an instance of "
":cpp:class:`GDALDefaultRasterAttributeTable`. An error is emitted if this"
" is not the case. This could potentially be extended to work with any "
"subclass of :cpp:class:`GDALRasterAttributeTable` but with significant "
"additional coding to create a thread-safe wrapper. "
"(GDALDefaultRasterAttributeTable is intrinsically thread-safe for read-"
"only operations). This is not perceived as a limitation for the intended "
"use cases of this RFC (reading pixel values in parallel)."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:252
msgid ""
"Some drivers, like netCDF, and HDF5 in some builds, use a global lock "
"around each call to their APIs, due to the underlying libraries not being"
" re-entrant. Obviously scalability of GDALThreadSafeDataset will be "
"limited by such global lock. But this is no different than the approach "
"of opening as many dataset as worker threads."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:260
msgid "Implementation details"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:262
msgid ""
"(This section is mostly of interest for developers familiar with GDAL "
"internals and may be skipped by users of the GDAL API)"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:265
msgid ""
"The gist of the implementation lies in a new file "
"``gcore/gdalthreadsafedataset.cpp`` which defines several classes "
"(internal details):"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:268
msgid ""
"``GDALThreadSafeDataset`` extending :cpp:class:`GDALProxyDataset`. "
"Instances of that class are returned by GDALGetThreadSafeDataset(). On "
"instantiation, it creates as many GDALThreadSafeRasterBand instances as "
"the number of bands of the source dataset. All virtual methods of "
"GDALDataset are redefined by GDALProxyDataset. GDALThreadSafeDataset "
"overloads its ReferenceUnderlyingDataset method, so that a thread-local "
"dataset is opened the first-time a thread calls a method on the "
"GDALThreadSafeDataset instance, cached for later use, and method call is "
"generally forwarded to it. There are exceptions for methods like "
":cpp:func:`GDALDataset::GetSpatialRef`, "
":cpp:func:`GDALDataset::GetGCPSpatialRef`, "
":cpp:func:`GDALDataset::GetGCPs`, :cpp:func:`GDALDataset::GetMetadata`, "
":cpp:func:`GDALDataset::GetMetadataItem` that return non-primitive types "
"where the calls are forwarded to the dataset used to construct "
"GDALThreadSafeDataset, with a mutex being taken around them. If the call "
"was otherwise forwarded to a thread-local instance, there would be a risk"
" of use-after-free situations when the returned value is used by "
"different threads."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:285
msgid ""
"``GDALThreadSafeRasterBand`` extending :cpp:class:`GDALProxyRasterBand`. "
"On instantiation, it creates child GDALThreadSafeRasterBand instances for"
" band mask and overviews. Its ReferenceUnderlyingRasterBand method calls "
"ReferenceUnderlyingDataset on the GDALThreadSafeDataset instance to get a"
" thread-local dataset, fetches the appropriate thread-local band and "
"generally forwards its the method call. There are exceptions for methods "
"like :cpp:func:`GDALRasterBand::GetUnitType`, "
":cpp:func:`GDALRasterBand::GetMetadata`, "
":cpp:func:`GDALRasterBand::GetMetadataItem` that return non-primitive "
"types where the calls are forwarded to the band used to construct "
"GDALThreadSafeRasterBand, with a mutex being taken around them, and the "
"returned value being ."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:297
msgid ""
"``GDALThreadLocalDatasetCache``. Instances of that class use thread-local"
" storage. The main member of such instances is a LRU cache that maps "
"GDALThreadSafeDataset* instances to a thread specific GDALDataset smart "
"pointer. On GDALThreadSafeDataset destruction, there's code to iterate "
"over all alive GDALThreadLocalDatasetCache instances and evict no-longer "
"needed entries in them, within a per-GDALThreadLocalDatasetCache instance"
" mutex, to avoid issues when dealing with several instances of "
"GDALThreadLocalDatasetCache... Note that the existence of this mutex "
"should not cause performance issues, since contention on it, should be "
"very low in real-world use cases (it could become a bottleneck if "
"GDALThreadSafeDataset were created and destroyed at a very high pace)"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:309
msgid ""
"Two protected virtual methods are added to GDALDataset for "
"GDALThreadSafeDataset implementation, and may be overloaded by drivers if"
" needed (but it is not anticipated that drivers but the MEM driver need "
"to do that)"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:313
msgid ""
"``bool CanBeCloned(int nScopeFlags, bool bCanShareState) const``. This "
"method determines if a source dataset can be \"cloned\" (or re-opened). "
"It returns true for instances returned by GDALOpenEx, for instances of "
"the MEM driver if ``nScopeFlags`` == ``GDAL_OF_RASTER`` (and "
"``bCanShareState`` is true for instances of the MEM driver)"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:319
msgid ""
"``std::unique_ptr<GDALDataset> Clone(int nScopeFlags, bool "
"bCanShareState) const``. This method returns a \"clone\" of the dataset "
"on which it is called, and is used by "
"GDALThreadSafeDataset::ReferenceUnderlyingDataset() when a thread-local "
"dataset is needed. Implementation of that method must be thread-safe. The"
" base implementation calls GDALOpenEx() reusing the dataset name, open "
"flags and open option. It is overloaded in the MEM driver to return a new"
" instance of MEMDataset, but sharing the memory buffers with the source "
"dataset."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:328
msgid ""
"No code in drivers, but the MEM driver, is modified by the candidate "
"implementation."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:331
msgid ""
"A few existing non-virtual methods of GDALDataset and GDALRasterBand have"
" been made virtual (and overloaded by GDALProxyDataset and "
"GDALProxyRasterBand), to avoid modifying state on the "
"GDALThreadSafeRasterBand instance, which wouldn't be thread-safe."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:336
msgid ""
":cpp:func:`GDALDataset::BlockBasedRasterIO`: it interacts with the block "
"cache"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:338
msgid ""
":cpp:func:`GDALRasterBand::GetLockedBlockRef`: it interacts with the "
"block cache"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:340
msgid ""
":cpp:func:`GDALRasterBand::TryGetLockedBlockRef`: it interacts with the "
"block cache"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:342
msgid ":cpp:func:`GDALRasterBand::FlushBlock`: it interacts with the block cache"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:344
msgid ":cpp:func:`GDALRasterBand::InterpolateAtPoint`: it uses a per-band cache"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:346
msgid ""
":cpp:func:`GDALRasterBand::EnablePixelTypeSignedByteWarning`: it should "
"already have been made virtual for GDALProxyRasterBand needs."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:349
msgid ""
"Non-virtual methods :cpp:func:`GDALDataset::GetProjectionRef` and "
":cpp:func:`GDALDataset::GetGCPProjection`, which cache the return value, "
"have been modify to apply a mutex when run on a dataset that "
"IsThreadSafe() to be effectively thread-safe."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:354
msgid ""
"A SetThreadSafe() method has been added to "
":cpp:class:`OGRSpatialReference`. When it is called, all methods of that "
"class run under a per-instance (recursive) mutex. This is used by "
"GDALThreadSafeDataset for its implementation of the "
":cpp:func:`GDALDataset::GetSpatialRef` and "
":cpp:func:`GDALDataset::GetGCPSpatialRef` methods, such that the returned"
" OGRSpatialReference instances are thread-safe."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:361
msgid "Performance"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:363
msgid ""
"The existing multireadtest utility that reads a dataset from multiple "
"threads has been extended with a -thread_safe flag to asks to use "
"GDAL_OF_THREAD_SAFE when opening the dataset in the main thread and use "
"it in the worker threads, instead of the default behavior of opening "
"explicitly a dataset in each thread. The thread-safe mode shows similar "
"scalability as the default mode, sometimes with a slightly decreased "
"efficiency, but not in a too problematic way."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:370
msgid "For example on a 20x20 raster:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:387
msgid ""
"But on a 4096x4096 raster with a number of iterations reduced to 100, the"
" timings between the default and thread_safe modes are very similar."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:390
msgid ""
"A Python equivalent of multireadtest has been written. Scalability "
"depends on how much Python code is executed. If relatively few long-"
"enough calls to GDAL are done, scalability tends to be good due to the "
"Python Global Interpreter Lock (GIL) being dropped around them. If many "
"short calls are done, the GIL itself, or its repeated acquisition and "
"release, becomes the bottleneck. This is no different than using a "
"GDALDataset per thread."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:398
msgid "Documentation"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:400
msgid ""
"Documentation for the new constant and functions will be added. The "
":ref:`multithreading` page will be updated to reflect the new capability "
"introduced by this RFC."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:405
msgid "Backward compatibility"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:407
msgid ""
"No issue anticipated: the C and C++ API are extended. The C++ ABI is "
"modified due to additions of new virtual methods."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:411
msgid "Testing"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:413
msgid ""
"Tests will be added for the new functionality, including stress tests to "
"have sufficiently high confidence in the correctness of the "
"implementation for common use cases."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:418
msgid "Risks"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:420
msgid ""
"Like all code related to multi-threading, the C++ language and tooling "
"offers hardly any safety belt against thread-safety programming errors. "
"So it cannot be excluded that the implementation suffers from  bugs in "
"some edge scenarios, or in the usage of some methods of GDALDataset, "
"GDALRasterBand and related objects (particularly existing non-virtual "
"methods of those classes that could happen to have a non thread-safe "
"implementation)"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:428
msgid "Design discussion"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:430
msgid ""
"This paragraph discusses a number of thoughts that arose during the "
"writing of this RFC."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:433
msgid ""
"A significantly different alternative could have consisted in adding "
"native thread-safety in each driver. But this is not realistic for the "
"following reasons:"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:436
msgid ""
"if that was feasible, it would require considerable development effort to"
" rework each drivers. So realistically, only a few select drivers would "
"be updated."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:439
msgid ""
"Even updating a reduced number of drivers would be extremely difficult, "
"in particular the GeoTIFF one, due to the underlying library not being "
"reentrant, and deferred loading strategies and many state variables being"
" modified even by read-only APIs. And this applies to most typical "
"drivers."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:444
msgid ""
"Due to the inevitable locks, there would be a (small) cost bore by "
"callers even on single-thread uses of thread-safe native drivers."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:447
msgid ""
"Some core mechanisms, particularly around the per-band block cache "
"structures, are not currently thread-safe."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:450
msgid ""
"A variant of the proposed implementation that did not use thread-local "
"storage has been initially attempted. It stored instead a "
"``std::map<thread_id, std::unique_ptr<GDALDataset>>`` on each "
"GDALThreadSafeDataset instance. This implementation was simpler, but "
"unfortunately suffered from high lock contention since a mutex had to be "
"taken around each access to this map, with the contention increasing with"
" the number of concurrent threads."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:457
msgid ""
"For the unusual situations where a dataset cannot be reopened and thus "
"GDALGetThreadSafeDataset() fails, should we provide an additional "
"``bForce`` argument to force it to still return a dataset, where calls to"
" the wrapped dataset are protected by a mutex? This would enable to "
"always write multi-thread safe code, even if the access to the dataset is"
" serialized. Similarly we could have a ``std::unique_ptr<GDALRasterBand> "
"GDALGetThreadSafeRasterBand(GDALRasterBand* poBand, int nOpenFlags, bool "
"bForce)`` function that would try to use GDALGetThreadSafeDataset() "
"internally if it manages to identify the dataset to which the band "
"belongs to, and otherwise would fallback to protecting calls to the "
"wrapped band with a mutex."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:468
msgid ""
"Given the absence of evidence that such option is necessary, this has "
"been excluded from the scope of this RFC."
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:473
msgid "Related issues and PRs"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:475
msgid "Candidate implementation: https://github.com/OSGeo/gdal/pull/10746"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:477
msgid ""
"https://github.com/OSGeo/gdal/issues/8448: GTiff: Allow concurrent "
"reading of single blocks"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:480
msgid "Voting history"
msgstr ""

#: ../../source/development/rfc/rfc101_raster_dataset_threadsafety.rst:482
msgid "+1 from PSC members KurtS, JukkaR, JavierJS and EvenR"
msgstr ""

