# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-07-01 04:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Yoichi Kayama <yoichi.kayama@gmail.com>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../source/tutorials/vector_driver_tut.rst:5
msgid "Vector driver implementation tutorial"
msgstr "ベクタードライバー実装チュートリアル"

#: ../../source/tutorials/vector_driver_tut.rst:10
msgid "Overall Approach"
msgstr "全体的なアプローチ"

#: ../../source/tutorials/vector_driver_tut.rst:12
msgid ""
"In general new formats are added to OGR by implementing format specific "
"drivers with instantiating a :cpp:class:`GDALDriver` and subclasses of "
":cpp:class:`GDALDataset` and :cpp:class:`OGRLayer`.  The GDALDriver "
"instance is registered with the :cpp:class:`GDALDriverManager` at "
"runtime."
msgstr ""
"一般的に,新しいフォーマットは,フォーマット固有のドライバーを実装し, :cpp:class:`GDALDriver` と :cpp:class:`GDALDataset` および "
" :cpp:class:`OGRLayer` のサブクラスをインスタンス化することでOGRに追加されます."
"GDALDriverインスタンスは,実行時に :cpp:class:`GDALDriverManager` に登録されます."

#: ../../source/tutorials/vector_driver_tut.rst:17
msgid ""
"Before following this tutorial to implement an OGR driver, please review "
"the :ref:`vector_data_model` document carefully."
msgstr ""
"OGRドライバーを実装するためにこのチュートリアルに従う前に, :ref:`vector_data_model` "
"ドキュメントを注意深く確認してください."

#: ../../source/tutorials/vector_driver_tut.rst:20
msgid "The tutorial will be based on implementing a simple ascii point format."
msgstr "このチュートリアルは,シンプルなasciiポイントフォーマットを実装することを基にしています."

#: ../../source/tutorials/vector_driver_tut.rst:23
msgid "Implementing GDALDriver"
msgstr "GDALDriverの実装"

#: ../../source/tutorials/vector_driver_tut.rst:25
msgid ""
"The format specific driver class is implemented as a instance of "
"GDALDriver. One instance of the driver will normally be created, and "
"registered with the GDALDriverManager.  The instantiation of the driver "
"is normally handled by a global C callable registration function, similar"
" to the following placed in the same file as the driver class."
msgstr ""
"フォーマット固有のドライバークラスは, GDALDriverのインスタンスとして実装されます."
"通常,ドライバーの1つのインスタンスが作成され, GDALDriverManagerに登録されます."
"ドライバーのインスタンス化は通常,グローバルなC呼び出し可能な登録関数によって処理されます."
"次のようなものが,ドライバークラスと同じファイルに配置されます."

#: ../../source/tutorials/vector_driver_tut.rst:55
msgid ""
"The :cpp:func:`GDALDriver::SetDescription` sets the name of the driver.  "
"This name is specified on the commandline when creating datasources so it"
" is generally good to keep it short and without any special characters or"
" spaces."
msgstr ""
":cpp:func:`GDALDriver::SetDescription` は,ドライバーの名前を設定します."
"この名前は,データソースを作成する際にコマンドラインで指定されるため,一般的には短くして,特殊文字やスペースを含めないようにすると良いでしょう."

#: ../../source/tutorials/vector_driver_tut.rst:59
msgid ""
"SetMetadataItem( GDAL_DCAP_VECTOR, \"YES\" ) is specified to indicate "
"that the driver will handle vector data."
msgstr ""
"SetMetadataItem( GDAL_DCAP_VECTOR, \"YES\" ) は,ドライバーがベクターデータを処理することを示すために指定されます."

#: ../../source/tutorials/vector_driver_tut.rst:62
msgid ""
"SetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" ) is specified to indicate "
"that the driver can deal with files opened with the VSI*L GDAL API. "
"Otherwise this metadata item should not be defined."
msgstr ""
"SetMetadataItem( GDAL_DCAP_VIRTUALIO, \"YES\" ) は,ドライバーがVSI*L GDAL APIで開かれたファイルを処理できることを示すために指定されます."
"それ以外の場合,このメタデータ項目は定義されていないはずです."

#: ../../source/tutorials/vector_driver_tut.rst:66
msgid ""
"For a driver that can be built as a plugin (that is to say a standalone "
"shared object, loaded at runtime by GDAL), since GDAL 3.9 and "
":ref:`rfc-96`, there is a way to implement the driver in a way where the "
"plugin will be loaded only when necessary, and not immediately at "
":cpp:func:`GDALAllRegister` time. Consult :ref:`rfc96_example_driver` for"
" the changes needed to make the driver compatible of deferred plugin "
"loading."
msgstr ""
"プラグインとしてビルドできるドライバー(つまり,実行時にGDALによってロードされるスタンドアロンの共有オブジェクト)の場合,"
"GDAL 3.9以降と :ref:`rfc-96` により,プラグインが必要なときにのみロードされ,すぐに :cpp:func:`GDALAllRegister` 時に"
"ロードされない方法でドライバーを実装する方法があります."
"遅延プラグインのロードに互換性のあるドライバーにするために必要な変更については, :ref:`rfc96_example_driver` を参照してください."

#: ../../source/tutorials/vector_driver_tut.rst:68
msgid ""
"The driver declaration generally looks something like this for a format "
"with read or read and update access (the Open() method) and creation "
"support (the Create() method)."
msgstr ""
"読み取りまたは読み取りおよび更新アクセス(Open() メソッド)と作成サポート(Create() メソッド)を持つフォーマットの場合,"
"ドライバーの宣言は一般的に次のようになります."

#: ../../source/tutorials/vector_driver_tut.rst:81
msgid ""
"The Open() method is called by :cpp:func:`GDALOpenEx`. It should quietly "
"return NULL if the passed filename is not of the format supported by the "
"driver.  If it is the target format, then a new GDALDataset object for "
"the dataset should be returned."
msgstr ""
"Open() メソッドは, :cpp:func:`GDALOpenEx` によって呼び出されます."
"渡されたファイル名がドライバーでサポートされているフォーマットでない場合は,静かにNULLを返すべきです."
"対象のフォーマットである場合は,データセットの新しいGDALDatasetオブジェクトを返すべきです."

#: ../../source/tutorials/vector_driver_tut.rst:85
msgid ""
"It is common for the Open() method to be delegated to an Open() method on"
" the actual format's GDALDataset class."
msgstr ""
"Open() メソッドが実際のフォーマットのGDALDatasetクラスのOpen() メソッドに委任されることが一般的です."

#: ../../source/tutorials/vector_driver_tut.rst:106
msgid "The Identify() method is implemented as such :"
msgstr "Identify() メソッドは次のように実装されます:"

#: ../../source/tutorials/vector_driver_tut.rst:118
msgid ""
"Examples of the Create() method is left for the section on creation and "
"update."
msgstr ""
"Create() メソッドの例は,作成と更新のセクションに残されています."

#: ../../source/tutorials/vector_driver_tut.rst:121
msgid "Basic Read Only Data Source"
msgstr "基本的な読み取り専用データソース"

#: ../../source/tutorials/vector_driver_tut.rst:123
msgid ""
"We will start implementing a minimal read-only datasource.  No attempt is"
" made to optimize operations, and default implementations of many methods"
" inherited from GDALDataset are used."
msgstr ""
"最小限の読み取り専用データソースの実装を開始します."
"操作を最適化しようとはせず,多くのメソッドのデフォルト実装を使用します."

#: ../../source/tutorials/vector_driver_tut.rst:127
msgid ""
"The primary responsibility of the datasource is to manage the list of "
"layers. In the case of the SPF format a datasource is a single file "
"representing one layer so there is at most one layer.  The \"name\" of a "
"datasource should generally be the name passed to the Open() method."
msgstr ""
"データソースの主な責任は,レイヤーのリストを管理することです."
"SPFフォーマットの場合,データソースは1つのレイヤーを表す単一のファイルであるため,最大1つのレイヤーがあります."
"データソースの\"名前\"は一般的にOpen() メソッドに渡される名前であるべきです."

#: ../../source/tutorials/vector_driver_tut.rst:132
msgid ""
"The Open() method below is not overriding a base class method, but we "
"have it to implement the open operation delegated by the driver class."
msgstr ""
"以下のOpen() メソッドは基底クラスメソッドをオーバーライドしていませんが,ドライバークラスによって委任されたオープン操作を実装するために持っています."

#: ../../source/tutorials/vector_driver_tut.rst:135
msgid ""
"For this simple case we provide a stub "
":cpp:func:`GDALDataset::TestCapability` that returns FALSE for all "
"extended capabilities.  The TestCapability() method is pure virtual, so "
"it does need to be implemented."
msgstr ""
"この単純なケースでは,すべての拡張機能に対してFALSEを返すスタブ :cpp:func:`GDALDataset::TestCapability` を提供します."
"TestCapability() メソッドは純粋仮想なので,実装する必要があります."

#: ../../source/tutorials/vector_driver_tut.rst:159
msgid ""
"The constructor is a simple initializer to a default state.  The Open() "
"will take care of actually attaching it to a file.  The destructor is "
"responsible for orderly cleanup of layers."
msgstr ""
"コンストラクタは,デフォルトの状態に初期化するためのシンプルな初期化子です."
"Open() は,実際にファイルにアタッチすることを担当します."
"デストラクタは,レイヤーの整理されたクリーンアップを担当します."

#: ../../source/tutorials/vector_driver_tut.rst:180
msgid ""
"The Open() method is the most important one on the datasource, though in "
"this particular instance it passes most of its work off to the "
"OGRSPFLayer constructor if it believes the file is of the desired format."
msgstr ""
"Open() メソッドは,データソース上で最も重要なメソッドですが,この特定のインスタンスでは,ファイルが目的のフォーマットであると信じている場合,"
"ほとんどの作業をOGRSPFLayerコンストラクタに委任します."

#: ../../source/tutorials/vector_driver_tut.rst:184
msgid ""
"Note that Open() methods should try and determine that a file isn't of "
"the identified format as efficiently as possible, since many drivers may "
"be invoked with files of the wrong format before the correct driver is "
"reached.  In this particular Open() we just test the file extension but "
"this is generally a poor way of identifying a file format.  If available,"
" checking \"magic header values\" or something similar is preferable."
msgstr ""
"Open() メソッドは,多くのドライバーが正しいドライバーに到達する前に,間違ったフォーマットのファイルで多くのドライバーが呼び出される可能性があるため,"
"ファイルが識別されたフォーマットでないことをできるだけ効率的に判断するべきです."
"この特定のOpen() では,ファイルの拡張子のみをテストしていますが,これは一般的にファイルフォーマットを識別するための悪い方法です."
"利用可能であれば,\"マジックヘッダー値\"などをチェックすることが望ましいです."

#: ../../source/tutorials/vector_driver_tut.rst:191
msgid ""
"In the case of the SPF format, update in place is not supported, so we "
"always fail if bUpdate is FALSE."
msgstr ""
"SPFフォーマットの場合,更新はサポートされていないため,bUpdate が FALSE の場合は常に失敗します."

#: ../../source/tutorials/vector_driver_tut.rst:218
msgid ""
"A GetLayer() method also needs to be implemented.  Since the layer list "
"is created in the Open() this is just a lookup with some safety testing."
msgstr ""
"GetLayer() メソッドも実装する必要があります."
"レイヤーリストはOpen() で作成されるため,これは単なるルックアップといくつかの安全テストです."

#: ../../source/tutorials/vector_driver_tut.rst:234
msgid "Read Only Layer"
msgstr "読み取り専用レイヤー"

#: ../../source/tutorials/vector_driver_tut.rst:236
msgid ""
"The OGRSPFLayer is implements layer semantics for an .spf file.  It "
"provides access to a set of feature objects in a consistent coordinate "
"system with a particular set of attribute columns.  Our class definition "
"looks like this:"
msgstr ""
"OGRSPFLayer は .spf ファイルのレイヤーセマンティクスを実装します."
"特定の属性列を持つ一貫した座標系で一連の地物オブジェクトにアクセスします."
"クラスの定義は次のようになります:"

#: ../../source/tutorials/vector_driver_tut.rst:263
msgid ""
"The layer constructor is responsible for initialization.  The most "
"important initialization is setting up the :cpp:class:`OGRFeatureDefn` "
"for the layer.  This defines the list of fields and their types, the "
"geometry type and the coordinate system for the layer.  In the SPF format"
" the set of fields is fixed - a single string field and we have no "
"coordinate system info to set."
msgstr ""
"レイヤーコンストラクタは初期化を担当します."
"最も重要な初期化は,レイヤーのための :cpp:class:`OGRFeatureDefn` を設定することです."
"これは,フィールドとそのタイプのリスト,ジオメトリタイプおよびレイヤーの座標系を定義します."
"SPFフォーマットでは,フィールドのセットが固定されています - 単一の文字列フィールドがあり,設定する座標系情報はありません."

#: ../../source/tutorials/vector_driver_tut.rst:269
msgid ""
"Pay particular attention to the reference counting of the OGRFeatureDefn."
" As OGRFeature's for this layer will also take a reference to this "
"definition, it is important that we also establish a reference on behalf "
"of the layer itself."
msgstr ""
"OGRFeatureDefn の参照カウントに特に注意してください."
"このレイヤーのOGRFeatureもこの定義への参照を取るため,レイヤー自体の代理で参照を確立することが重要です."

#: ../../source/tutorials/vector_driver_tut.rst:295
msgid ""
"Note that the destructor uses :cpp:func:`OGRFeatureDefn::Release` on the "
"OGRFeatureDefn.  This will destroy the feature definition if the "
"reference count drops to zero, but if the application is still holding "
"onto a feature from this layer, then that feature will hold a reference "
"to the feature definition and it will not be destroyed here (which is "
"good!)."
msgstr ""
"デストラクタは,OGRFeatureDefn に :cpp:func:`OGRFeatureDefn::Release` を使用します."
"参照カウントがゼロになるとフィーチャ定義が破棄されますが,アプリケーションがこのレイヤーから地物を保持している場合,"
"その地物は地物定義への参照を保持し,ここで破棄されません(これは良いことです!)."

#: ../../source/tutorials/vector_driver_tut.rst:311
msgid ""
"The :cpp:func:`OGRLayer::GetNextFeature` method is usually the work horse"
" of OGRLayer implementations.  It is responsible for reading the next "
"feature according to the current spatial and attribute filters installed."
msgstr ""
":cpp:func:`OGRLayer::GetNextFeature` メソッドは,通常,OGRLayer実装の主要な役割を果たします."
"現在の空間フィルターと属性フィルターに従って次のフィーチャを読み取る責任があります."

#: ../../source/tutorials/vector_driver_tut.rst:315
msgid ""
"The while() loop is present to loop until we find a satisfactory feature."
"  The first section of code is for parsing a single line of the SPF text "
"file and establishing the x, y and name for the line."
msgstr ""
"while() ループは,満足のいくフィーチャが見つかるまでループするために存在します."
"最初のコードセクションは,SPFテキストファイルの1行を解析し,その行のx, y, nameを確立するためのものです."

#: ../../source/tutorials/vector_driver_tut.rst:351
msgid ""
"The next section turns the x, y and name into a feature.  Also note that "
"we assign a linearly incremented feature id.  In our case we started at "
"zero for the first feature, though some drivers start at 1."
msgstr ""
"次のセクションでは, x, y, name を地物に変換します."
"また,線形に増加する地物IDを割り当てることに注意してください."
"この場合,最初の地物はゼロから始めましたが,一部のドライバーは1から始めます."

#: ../../source/tutorials/vector_driver_tut.rst:364
msgid ""
"Next we check if the feature matches our current attribute or spatial "
"filter if we have them.  Methods on the OGRLayer base class support "
"maintain filters in the OGRLayer member fields "
":cpp:member:`OGRLayer::m_poFilterGeom` (spatial filter) and "
":cpp:member:`OGRLayer::m_poAttrQuery` (attribute filter) so we can just "
"use these values here if they are non-NULL.  The following test is "
"essentially \"stock\" and done the same in all formats.  Some formats "
"also do some spatial filtering ahead of time using a spatial index."
msgstr ""
"次に,現在の属性フィルターまたは空間フィルターがある場合,地物がそれに一致するかどうかをチェックします."
"OGRLayerベースクラスのメソッドは,OGRLayerメンバーフィールド :cpp:member:`OGRLayer::m_poFilterGeom` (空間フィルター) および"
" :cpp:member:`OGRLayer::m_poAttrQuery` (属性フィルター) をサポートしているため,これらの値がNULLでない場合はここでこれらの値を使用できます."
"以下のテストは基本的に\"標準\"であり,すべてのフォーマットで同じように行われます."
"一部のフォーマットは,空間インデックスを使用して事前に空間フィルタリングも行います."

#: ../../source/tutorials/vector_driver_tut.rst:372
msgid ""
"If the feature meets our criteria we return it.  Otherwise we destroy it,"
" and return to the top of the loop to fetch another to try."
msgstr ""
"地物が基準を満たす場合は,それを返します."
"それ以外の場合は,それを破棄し,もう一度取得して試すためにループの先頭に戻ります."

#: ../../source/tutorials/vector_driver_tut.rst:387
msgid ""
"While in the middle of reading a feature set from a layer, or at any "
"other time the application can call :cpp:func:`OGRLayer::ResetReading` "
"which is intended to restart reading at the beginning of the feature set."
"  We implement this by seeking back to the beginning of the file, and "
"resetting our feature id counter."
msgstr ""
"レイヤーから地物セットを読み取っている途中,または他の任意の時点でアプリケーションは, :cpp:func:`OGRLayer::ResetReading` を呼び出すことができます."
"これは,地物セットの先頭からの読み取りを再開することを意図しています."
"これは,ファイルの先頭にシークし,地物IDカウンターをリセットすることで実装します."

#: ../../source/tutorials/vector_driver_tut.rst:400
msgid ""
"In this implementation we do not provide a custom implementation for the "
"GetFeature() method.  This means an attempt to read a particular feature "
"by its feature id will result in many calls to GetNextFeature() until the"
" desired feature is found.  However, in a sequential text format like spf"
" there is little else we could do anyway."
msgstr ""
"この実装では,GetFeature() メソッドにカスタム実装を提供していません."
"これは,地物IDで特定の地物を読み取ろうとすると,望ましい地物が見つかるまでGetNextFeature() が多く呼び出されることを意味します."
"しかし,spfのような連続テキストフォーマットでは,他にすることはほとんどありません."

#: ../../source/tutorials/vector_driver_tut.rst:406
msgid "There! We have completed a simple read-only feature file format driver."
msgstr "以上! シンプルな読み取り専用地物ファイルフォーマットドライバーが完成しました."

