# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1998-2024
# This file is distributed under the same license as the GDAL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GDAL \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-31 22:42+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Yoichi Kayama <yoichi.kayama@gmail.com>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../source/user/multithreading.rst:5
msgid "Multi-threading"
msgstr "マルチスレッディング"

#: ../../source/user/multithreading.rst:8
#, fuzzy
msgid "GDAL API: re-entrant, but (generally) not thread-safe"
msgstr "GDAL-API: 再入可能だが,スレッドセーフではない"

#: ../../source/user/multithreading.rst:10
msgid ""
"The exact meaning of the terms ``thread-safe`` or ``re-entrant`` is not "
"fully standardized. We will use here the `QT definitions "
"<https://doc.qt.io/qt-5/threads-reentrancy.html>`__. In particular, a C "
"function or C++ method is said to be re-entrant if it can be called "
"simultaneously from multiple threads, *but* only if each invocation uses "
"its own data."
msgstr ""
"用語  ``スレッドセーフ`` または ``再入可能`` の正確な意味は完全に標準化されていません.ここでは, `QTの定義 "
"<https://doc.qt.io/qt-5/threads-reentrancy.html>`__ を使用します. 特に, "
"C関数またはC++メソッドは, 複数のスレッドから同時に呼び出すことができると言われます. *しかし* "
"各呼び出しが独自のデータを使用する場合のみ, 再入可能であるとされます."

#: ../../source/user/multithreading.rst:16
msgid "All GDAL public C functions and C++ methods are re-entrant, except:"
msgstr "すべてのGDAL公開C関数とC++メソッドは再入可能ですが, 以下の例外があります:"

#: ../../source/user/multithreading.rst:18
msgid "the general initialization functions, like :cpp:func:`GDALAllRegister`."
msgstr ":cpp:func:`GDALAllRegister` のような一般的な初期化関数."

#: ../../source/user/multithreading.rst:19
msgid ""
"the general cleanup functions like :cpp:func:`GDALDestroy` or "
":cpp:func:`OSRCleanup`."
msgstr ":cpp:func:`GDALDestroy` や :cpp:func:`OSRCleanup` のような一般的なクリーンアップ関数."

#: ../../source/user/multithreading.rst:21
msgid ""
"Those functions should not be called concurrently from several threads, "
"and it is general best practice to call them from the main thread of the "
"program at program initialization and termination."
msgstr ""
"これらの関数は複数のスレッドから同時に呼び出すべきではありません.また, プログラムの初期化と終了時には, "
"一般的にこれらの関数をプログラムのメインスレッドから呼び出すのがベストプラクティスです."

#: ../../source/user/multithreading.rst:25
msgid ""
"Unless otherwise stated, no GDAL public C functions and C++ methods "
"should be assumed to be thread-safe. That is you should not call "
"simultaneously GDAL functions from multiple threads on the same data "
"instance, or even instances that are closely related through ownership "
"relationships. For example, for a multi-band raster dataset, it is not "
"safe to call concurrently GDAL functions on different "
":cpp:class:`GDALRasterBand` instances owned by the same "
":cpp:class:`GDALDataset` instance (each thread should instead manipulate "
"a distinct GDALDataset). Similarly for a GDALDataset owning several "
":cpp:class:`OGRLayer`."
msgstr ""
"特に指定されていない限り, GDAL公開C関数とC++メソッドはスレッドセーフであると仮定してはいけません. つまり, "
"同じデータインスタンスに対して複数のスレッドから同時にGDAL関数を呼び出すべきではありません. また, "
"所有関係を通じて密接に関連しているインスタンスに対しても同様です. たとえば, マルチバンドラスターデータセットの場合,同じ "
":cpp:class:`GDALDataset` インスタンスによって所有されている異なる :cpp:class:`GDALRasterBand`"
" インスタンスに対して同時にGDAL関数を呼び出すことは安全ではありません "
"(各スレッドは代わりに異なるGDALDatasetを操作するべきです). 同様に, 複数の :cpp:class:`OGRLayer` "
"を所有するGDALDatasetの場合も同様です."

#: ../../source/user/multithreading.rst:34
msgid ""
"The reason is that most implementations of GDALDataset or GDALRasterBand "
"are stateful. A GDALDataset typically owns a file handle, and performs "
"seek/read operations on it, thus not allowing concurrent access. Block "
"cache related structures for a given GDALDataset are not thread-safe. "
"Drivers also often implement lazy initialization strategies to access "
"various metadata which are resolved only the first time the method to "
"access them is invoked. Drivers may also rely on third-party libraries "
"that expose objects that are not thread-safe."
msgstr ""
"その理由は, GDALDatasetやGDALRasterBandのほとんどの実装が状態を持っているためです.GDALDatasetは通常, "
"ファイルハンドルを所有し, それに対してシーク/読み取り操作を行うため,同時アクセスを許可しません. "
"特定のGDALDatasetに関連するブロックキャッシュ関連の構造はスレッドセーフではありません. ドライバは, "
"さまざまなメタデータにアクセスするための遅延初期化戦略を実装することがよくあり, "
"これらのメタデータにアクセスするためのメソッドが初めて呼び出されたときにのみ解決されます. ドライバはまた, "
"スレッドセーフでないオブジェクトを公開するサードパーティライブラリに依存することがあります."

#: ../../source/user/multithreading.rst:43
msgid ""
"Those restrictions apply to the C and C++ ABI, and all languages bindings"
" (unless they would take special precautions to serialize calls)"
msgstr "これらの制限は, CおよびC++のABI, およびすべての言語バインディングに適用されます(特別な注意を払って呼び出しを直列化する場合を除く)"

#: ../../source/user/multithreading.rst:47
msgid "Thread-safe GDAL dataset instances for raster read-only use cases"
msgstr ""

#: ../../source/user/multithreading.rst:51
msgid ""
"RFC 101 adds a new capability to open, or obtain, a thread-safe dataset "
"from any dataset, but only for raster read-only use cases."
msgstr ""

#: ../../source/user/multithreading.rst:54
msgid ""
"At open time, this can be done by passing ``GDAL_OF_RASTER | "
"GDAL_OF_THREAD_SAFE`` to :cpp:func:`GDALOpenEx` / "
":cpp:func:`GDALDataset::Open`."
msgstr ""

#: ../../source/user/multithreading.rst:57
msgid ""
"Given an existing GDALDataset* instance, "
":cpp:func:`GDALDataset::IsThreadSafe` can be used to determine if it is "
"thread-safe or not. If not, :cpp:func:`GDALDataset::GetThreadSafeDataset`"
" can be used."
msgstr ""

#: ../../source/user/multithreading.rst:61
msgid ""
"Note that the generic implementation of this capability involves opening "
"one dataset the first time a thread-safe dataset/raster band is accessed "
"by a thread. While this is an implementation detail that can be ignored "
"to develop code, it is important to note regarding potential performance "
"impacts"
msgstr ""

#: ../../source/user/multithreading.rst:67
msgid "GDAL block cache and multi-threading"
msgstr "GDALブロックキャッシュとマルチスレッディング"

#: ../../source/user/multithreading.rst:69
msgid ""
"The current design of the GDAL raster block cache allows concurrent reads"
" of several datasets. However performance issues may arise when writing "
"several datasets from several threads, due to lock contention in the "
"global structures of the block cache mechanism."
msgstr ""
"現在のGDALラスターブロックキャッシュの設計では, 複数のデータセットの同時読み取りが許可されています. ただし, "
"複数のスレッドから複数のデータセットに書き込む場合, "
"ブロックキャッシュメカニズムのグローバル構造体でのロック競合によるパフォーマンス問題が発生する可能性があります."

#: ../../source/user/multithreading.rst:74
msgid "RAM fragmentation and multi-threading"
msgstr "RAMの断片化とマルチスレッディング"

#: ../../source/user/multithreading.rst:76
msgid ""
"It has been observed that scenarios that involve multi-threading reading "
"or writing of raster datasets are prone to cause a high RAM usage, in "
"particular when using the default dynamic memory allocator of Linux. "
"Using the alternate `tcmalloc <https://github.com/google/tcmalloc>`__ "
"memory allocator helps reducing the amount of virtual and resident memory"
" used."
msgstr ""
"ラスターデータセットの読み取りまたは書き込みを行うマルチスレッディングを含むシナリオは,Linuxのデフォルトの動的メモリアロケータを使用している場合,"
" 高いRAM使用量を引き起こす傾向があることが観察されています. 代替の `tcmalloc  "
"<https://github.com/google/tcmalloc>`__ メモリアロケータを使用すると, "
"使用される仮想メモリと常駐メモリの量を減らすのに役立ちます."

#: ../../source/user/multithreading.rst:82
msgid ""
"For example, with Debian/Ubuntu distributions, this can be done by "
"installing the ``libtcmalloc-minimal4`` package and running the binary "
"that executes GDAL with:"
msgstr ""
"たとえば, Debian/Ubuntuディストリビューションでは, ``libtcmalloc-minimal4`` パッケージをインストールし,"
" GDALを実行するバイナリを次のように実行することで, これを行うことができます:"

#: ../../source/user/multithreading.rst:91
msgid "GDAL and multi-processing"
msgstr "GDALとマルチプロセッシング"

#: ../../source/user/multithreading.rst:93
msgid ""
"POSIX fork() API should not be called during the middle of a GDAL "
"operation, otherwise some structures like mutexes might appear to be "
"locked forever in the forked process. If multi-processing is done, we "
"recommend that processes are forked before any GDAL operation is done. "
"Operating on the same GDALDataset instance in several sub-processes will "
"generally lead to wrong results due to the underlying file descriptors "
"being shared."
msgstr ""
"GDAL操作の途中でPOSIX fork() APIを呼び出すべきではありません. そうしないと, "
"フォークされたプロセスでミューテックスなどの構造体が永遠にロックされたように見える可能性があります. マルチプロセッシングを行う場合, "
"GDAL操作を行う前にプロセスをフォークすることをお勧めします. 複数のサブプロセスで同じGDALDatasetインスタンスに操作を行うと, "
"基になるファイルディスクリプタが共有されているため, 一般的に誤った結果になります."

